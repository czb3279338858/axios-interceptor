# 简介
- 这个库主要提供了独立请求层的一些思路，其中包括一些常用的 axios 拦截器，另外还包括了独立请求层的一些范例
- 能力有限，这些拦截器大部分是互相耦合的，只有少数是可供选择的，下文将提供了一个完整范例
- 有任何疑问或建议请添加微信 WeiXin-CZB

# 初衷：探讨更易于维护的代码组织方式
- 以下说明是基于 vue 体系
- 组件主要分为页面级组件和其他组件
  - 页面级组件指直接被路由引用的组件
  - 其余的都被归为其他组件
- 每个页面级组件应该独立存放在一个文件夹中
  - 这个文件夹应当包含该页面组件下的子孙组件
  - 一个其他组件被多个页面组件使用时应该放在公共组件文件内
  - 一个放在公共组件文件内的组件应完全解耦
    - 不包含具体的业务，而只是提供视图复用
    - 应严格遵守 props 和 emit 传递数据
- 一个页面级组件经常会出现多个运用场景
  - 例如：详情页经常包含创建、编辑、查看3个场景
  - 例如：详情页可能是个人订单详情、可能是集团订单详情，根据不同的入口页展示不同的内容
  - 这种场景区分应当在 props 中接收参数，在迭代过程中对于页面组件的修改，应当先查看 props 内的参数来了解当前页面可能存在的使用场景
- 局部公共状态
  - 页面级组件和其子孙组件经常需要共同操作一个状态
    - 例如：一个表单数据在页面级组件中获取初始值，然后在各个子孙组件中进行操作
    - 例如：在页面级组件中点击保存，需要操作所有子孙组件中的表单进行校验
  - vuex 是设计用来存储全局公共状态的，并不适用于局部公共状态，个人建议全局也别用
  - 目前没有较完善的方案解决这个问题，个人建议使用 provide/inject 实现
    - 在页面级组件中定义好状态，然后 provide 给子孙组件
    - 结合 compositionAPI，在页面级组件中定义 ref，然后 provide 给子孙组件供给 form 组件绑定
- 独立请求层
  - 这才是是该项目的初衷（划重点！划重点！划重点！）
  - 先列举些使用场景：
  - 在业务代码中往往会定义一些状态用于存储异步请求获取的中间变量
    - 例如：字典翻译总需要一个存储字典列表的状态，然后在业务代码中维护状态的初始化。
    - 在迭代过程中如果要删除某个视图，最常做的就是注释对应的 template，其相关的 js 逻辑就不以理会
    - 所以，这种只和视图相关却和业务无关的状态，在迭代过程中往往成为无效代码
    - 我们期望能够在不影响性能的情况直接把 js 绑定到 template 中
    - 例如：字典翻译直接绑定一个同步函数，只需要传入翻译的 value 和对应字典的 key，其余的都由请求层处理，业务代码中不再需要关心异步问题
  - 在业务代码中有些接口的数据往往需要反复使用
    - 例如：当前用户的某些信息，往往做为其他接口的参数
    - 这看起来是一个显而易见的全局状态问题，应当使用 vuex 进行处理
    - 当第一次请求后就将数据写入 vuex 中，然后其他用户就可以直接到 vuex 中去获取
    - 但是这样获取数据的代码和使用数据的代码往往被拆分在两个文件中
    - 对于获取数据的代码进行修改将会造成不可预知的错误
    - 我们期望在每次需要数据使就调用接口去获取，至于需不需要真的向服务端发起请求就不需要操心
    - 这样使每个组件都是解耦的，只需要依赖请求层，不需要依赖其他组件
